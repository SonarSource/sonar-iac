/*
 * SonarQube IaC Plugin
 * Copyright (C) 2021-2026 SonarSource Sàrl
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the Sonar Source-Available License Version 1, as published by SonarSource Sàrl.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Sonar Source-Available License for more details.
 *
 * You should have received a copy of the Sonar Source-Available License
 * along with this program; if not, see https://sonarsource.com/license/ssal/
 */
@file:Suppress("ktlint:standard:filename")

package org.sonar.iac

import java.io.File
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.time.Duration
import org.gradle.api.logging.Logger

data class Rule(
    val id: String,
    val title: String,
    val url: String,
    val description: String,
    val tags: List<String>,
    val type: String,
    val severity: String? = null,
    val attribute: String,
    val softwareQuality: String,
    val qualityImpact: String,
)

/**
 * Convert a rule to a JSON string that is to be included into `rules.json`.
 *
 * Note: url ends with `#<id>` to allow direct linking to the rule in the documentation. Even though there are no HTML anchors, there is an invisible
 * link generated by Github with an attribute `name="user-content-<id>"` that can be used as an anchor.
 */
fun Rule.asJson(margin: Int): String =
    """
        {
          "key": "$id",
          "name": "$title",
          "url": "$url",
          "tags": ${tags.takeIf { it.isNotEmpty() }?.joinToString(prefix = "[", postfix = "]", separator = ",") { "\"$it\"" } ?: "[]"},
          "description": "${description.asSafeJson()}",
          "constantDebtMinutes": 5,
          "type": "$type",
          ${severity?.let { """"severity": "$it",""" } ?: ""}
          "code": {
            "attribute": "$attribute",
            "impacts": {
              "$softwareQuality": "$qualityImpact"
            }
          }
        }
    """.trimIndent()
        .lineSequence()
        .filterNot { it.isBlank() }
        .joinToString(separator = "\n") { "|${" ".repeat(margin)}$it" }

fun String.asSafeJson() =
    // escape an unescaped quote
    replace("""([^\\])"""".toRegex(), """$1\\"""")

/**
 * Create a fallback rule for an external linter.
 * Fallback rules are used when a custom or unknown rule is encountered.
 *
 * @param toolId ID of the external tool (e.g., "hadolint", "ansible-lint")
 * @param toolName Name of the external tool (e.g., "Hadolint", "Ansible Lint")
 * @param docUrl Base URL for the tool's documentation
 * @return A fallback Rule with standard classification
 */
fun createFallbackRule(
    toolId: String,
    toolName: String = toolId.replaceFirstChar { it.uppercase() },
    docUrl: String,
): Rule =
    Rule(
        id = "$toolId.fallback",
        title = "$toolName Rule",
        url = docUrl,
        description = "This reporting may be triggered by a custom $toolName rule or by a default $toolName rule " +
            "that has not yet been added to the Sonar IaC analyzer.",
        tags = listOf(toolId.lowercase()),
        type = "CODE_SMELL",
        severity = "MAJOR",
        attribute = "CONVENTIONAL",
        softwareQuality = "MAINTAINABILITY",
        qualityImpact = "MEDIUM"
    )

/**
 * Write a list of rules to a JSON file in the standard format.
 * This function generates the rules.json file with proper formatting.
 *
 * @param rules List of rules to write
 * @param file Target file to write the JSON content to
 */
fun writeRulesJson(
    rules: List<Rule>,
    file: File,
) {
    file.writeText(
        """
            |[
            ${rules.joinToString(separator = ",\n") { it.asJson(margin = 2) }}
            |]
        """.trimMargin().plus("\n")
    )
}

/**
 * Fetch the list of markdown files in a GitHub repository directory using the GitHub API.
 * This function makes an unauthenticated request to the GitHub API to list directory contents.
 *
 * @param githubUrl GitHub URL in the format: https://github.com/{owner}/{repo}/blob/{branch}/{path}/
 * @param logger Logger for informational and warning messages
 * @return A set of filenames (without .md extension) that exist in the directory, or empty set on failure
 */
fun fetchGitHubDirectoryMarkdownFiles(
    githubUrl: String,
    logger: Logger,
): Set<String> {
    val urlPattern = """https://github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+?)/?$""".toRegex()
    val matchResult = urlPattern.find(githubUrl) ?: error("Failed to parse GitHub URL: $githubUrl")

    val (owner, repo, branch, path) = matchResult.destructured

    // GitHub API endpoint for directory contents
    val apiUrl = "https://api.github.com/repos/$owner/$repo/contents/$path?ref=$branch"

    logger.info("Fetching file list from GitHub API: $apiUrl")

    return try {
        val client = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build()

        val request = HttpRequest.newBuilder()
            .uri(URI.create(apiUrl))
            .header("Accept", "application/vnd.github.v3+json")
            .timeout(Duration.ofSeconds(10))
            .GET()
            .build()

        val response = client.send(request, HttpResponse.BodyHandlers.ofString())

        if (response.statusCode() != 200) {
            logger.warn("Failed to fetch directory listing from GitHub API (status ${response.statusCode()}): $apiUrl")
            return emptySet()
        }

        val fileNamePattern = """"name"\s*:\s*"([^"]+\.md)"""".toRegex()
        fileNamePattern.findAll(response.body())
            .map { it.groupValues[1].removeSuffix(".md") }
            .toSet()
            .also { files ->
                logger.info("Found ${files.size} markdown files")
            }
    } catch (e: Exception) {
        logger.warn("Failed to fetch GitHub directory listing: $apiUrl", e)
        emptySet()
    }
}
