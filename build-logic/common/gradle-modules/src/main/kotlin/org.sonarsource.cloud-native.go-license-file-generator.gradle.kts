/*
 * SonarSource Cloud Native Gradle Modules
 * Copyright (C) 2024-2026 SonarSource Sàrl
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the Sonar Source-Available License Version 1, as published by SonarSource Sàrl.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Sonar Source-Available License for more details.
 *
 * You should have received a copy of the Sonar Source-Available License
 * along with this program; if not, see https://sonarsource.com/license/ssal/
 */
import java.io.File
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import org.gradle.api.GradleException
import org.gradle.api.logging.Logger
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.findByType
import org.sonarsource.cloudnative.gradle.GoLicenseGenerationConfig
import org.sonarsource.cloudnative.gradle.areDirectoriesEqual
import org.sonarsource.cloudnative.gradle.copyDirectory

/**
 * This plugin is used for generating license files for third-party GO runtime-dependencies into the resources folder.
 * It provides a validation task to ensure that the license files in the resource folder are up-to-date.
 * It provides a task to regenerate the license files into the resources folder.
 * These tasks expect the licenses to be generated by go-licenses by another task first, which is configurable.
 */

val goLicenseGenerationConfig =
    extensions.findByType<GoLicenseGenerationConfig>() ?: extensions.create<GoLicenseGenerationConfig>("goLicenseGenerationConfig")
goLicenseGenerationConfig.buildGoLicenseFilesDir.convention(project.layout.buildDirectory.dir("go-licenses").get().asFile)
goLicenseGenerationConfig.packagedBinaries.convention(emptySet())
goLicenseGenerationConfig.binaryLicenseFile.convention(project.rootDir.resolve("LICENSE.txt"))

var resourceLicenseDir = project.layout.projectDirectory.dir("src/main/resources/licenses")

val validateGoLicenses = tasks.register("validateGoLicenseFiles") {
    description = "Validate that generated go license files match the committed ones"
    group = "validation"
    dependsOn(generateGoLicenses)

    doLast {
        val generatedLicenses = goLicenseGenerationConfig.buildGoLicenseFilesDir.get().resolve("resources")
        goLicenseGenerationConfig.packagedBinaries.get().forEach {
            val licenseResourcesForBinary = resourceLicenseDir.dir("$it-licenses").asFile
            if (!areDirectoriesEqual(generatedLicenses, licenseResourcesForBinary, logger)) {
                val message = """
                [FAILURE] License file validation failed!
                Generated license files differ from committed files at $resourceLicenseDir.
                To update the committed license files, run './gradlew generateLicenseResources' and commit the changes.

                Note: This will completely regenerate all license files under $resourceLicenseDir and remove any stale ones.
                """
                throw GradleException(message)
            } else {
                logger.lifecycle("Go license file validation succeeded: Generated go license files match the committed ones.")
            }
        }
    }
}

tasks.named("validateLicenseFiles") {
    dependsOn(validateGoLicenses)
}

/**
 * This tasks requires that the go-license generation is already done
 * during 'goLicenseGenerationConfig.generatingGoLicensesGradleTask.' task.
 */
val generateGoLicenses = tasks.register("generateGoLicenses") {
    // Generating the licenses with go-license tool is done during 'dockerCompileGo' task
    dependsOn(goLicenseGenerationConfig.generatingGoLicensesGradleTask.get())
    doLast {
        transformGoLicenseOutputToDesiredLicenseStructure(goLicenseGenerationConfig.buildGoLicenseFilesDir.get(), logger)

        // copy included license
        val newIncludedLicensePath = goLicenseGenerationConfig.buildGoLicenseFilesDir.get().resolve("resources/LICENSE.txt").toPath()
        Files.copy(goLicenseGenerationConfig.binaryLicenseFile.get().toPath(), newIncludedLicensePath, StandardCopyOption.REPLACE_EXISTING)
    }
}

val generateGoLicenseResources = tasks.register("generateGoLicenseResources") {
    description = "Copies generated license files to the resources directory"
    dependsOn(generateGoLicenses)

    doLast {
        val generatedLicenses = goLicenseGenerationConfig.buildGoLicenseFilesDir.get().resolve("resources")
        goLicenseGenerationConfig.packagedBinaries.get().forEach {
            val licenseResourcesForBinary = resourceLicenseDir.dir("$it-licenses").asFile

            Files.createDirectories(licenseResourcesForBinary.toPath())
            copyDirectory(generatedLicenses, licenseResourcesForBinary, logger)
        }
    }
}

tasks.named("generateLicenseResources") {
    dependsOn(generateGoLicenseResources)
}

fun transformGoLicenseOutputToDesiredLicenseStructure(
    licenseFolder: File,
    logger: Logger,
) {
    val generatedDirectory = licenseFolder.resolve("generated").toPath()
    val transformedDirectory = licenseFolder.resolve("resources/THIRD_PARTY_LICENSES").toPath()

    // 1. Validation: Ensure input exists
    if (!Files.isDirectory(generatedDirectory)) {
        throw GradleException("Error: The directory '$generatedDirectory' does not exist.")
    }

    // Create output directory if it doesn't exist
    if (!Files.exists(transformedDirectory)) {
        Files.createDirectories(transformedDirectory)
    }

    logger.lifecycle("Processing files from: $generatedDirectory")

    try {
        // 2. Walk the tree and collect all regular files
        val allGeneratedFiles = Files.walk(generatedDirectory)
            .filter { Files.isRegularFile(it) }
            .toList()
        // 3. Group files by their parent directory
        val filesByDirectory = allGeneratedFiles.groupBy { it.parent }

        // 4. Iterate through each directory group
        filesByDirectory.forEach { (parentDir, filesInDir) ->

            // Find "LICENSE", otherwise take the first existing file
            val selectedFile = filesInDir.find { it.toFile().name.startsWith("LICENSE") }
                ?: filesInDir.first()

            // 5. Create the new filename

            // Get path relative to "licenses" (e.g., "my/directory/structure/LICENSE")
            val relativePath = generatedDirectory.relativize(parentDir)
            val newFileName = relativePath.toString().replace(File.separator, ".") + "-LICENSE.txt"

            // 6. Copy to output
            val destinationPath = transformedDirectory.resolve(newFileName)

            Files.copy(selectedFile, destinationPath, StandardCopyOption.REPLACE_EXISTING)
        }
    } catch (e: Exception) {
        logger.warn("An error occurred: ${e.message}", e)
        throw e
    }
}
