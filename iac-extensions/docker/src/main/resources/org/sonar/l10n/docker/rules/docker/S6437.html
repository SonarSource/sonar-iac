<h2>Why is this an issue?</h2>
<p>Sensitive data has been found in the Dockerfile or Docker image. The data should be considered breached.</p>
<p>If malicious third parties can get a hold of such information, they could impersonate legitimate identities within the organization.<br> It is a
clear breach of trust in the system, as the systems involved falsely assume that the authenticated entity is who it claims to be.<br> The consequences
can be catastrophic.</p>
<p>In Dockerfiles, secrets hard-coded, secrets passed through as variables or created at build-time will cause security risks. The secret information
can be exposed either via the container environment itself, the image metadata or the build environment logs.</p>
<p>Docker Buildkit’s secret mount options should be used when secrets have to be accessed at build time. For run-time secrets, best practices would
recommend only setting them at runtime, for example with the <code>--env</code> option of the docker run command.</p>
<p>Note that files exposing the secrets should be securely stored and not exposed to a large sphere. If possible, use a secret vault or another
similar component. For example, <strong>Docker Swarm</strong> provides a <strong>secrets</strong> service that can be used to handle most confidential
data.</p>
<h3>Noncompliant code example</h3>
<p>The following code snippet demonstrates the creation of a file with a private key and a public key, which are then stored in the metadata of the
container.<br> This is non-compliant, as the private key should not be exposed anywhere.</p>
<pre data-diff-id="1" data-diff-type="noncompliant">
FROM example

# Noncompliant
RUN ssh-keygen -N "passphrase" -t rsa -b 2048 -f /etc/ssh/rsa_key

RUN /example.sh --ssh /etc/ssh/rsa_key
</pre>
<p>In the following sample, the code uses a seemingly-hidden password which is actually leaked after the container is built.</p>
<pre data-diff-id="2" data-diff-type="noncompliant">
FROM example
ARG PASSWORD

# Noncompliant
RUN wget --user=guest --password="$PASSWORD" https://example.com
</pre>
<h3>Compliant solution</h3>
<p>For build-time secrets, use <a href="https://docs.docker.com/engine/reference/builder/#run---mounttypesecret">Buildkit’s secret mount type</a>
instead:</p>
<pre data-diff-id="1" data-diff-type="compliant">
FROM example

RUN --mount=type=secret,id=ssh,target=/etc/ssh/rsa_key \
    /example.sh --ssh /etc/ssh/rsa_key
</pre>
<pre data-diff-id="2" data-diff-type="compliant">
FROM example

RUN --mount=type=secret,id=wget_passwd \
    wget --user=guest --password="$(cat /run/secrets/wget_passwd)" https://example.com
</pre>
<p>For runtime secrets, leave the environment variables empty in the Dockerfile. Then store the runtime secrets in an <a
href="https://docs.docker.com/compose/env-file/">environment file</a> such as <code>.env</code> and then start the container with the <a
href="https://docs.docker.com/engine/reference/commandline/run/#set-environment-variables—​e---env---env-file"><code>--env-file</code></a>
argument:</p>
<pre>
docker run --env-file .env myImage
</pre>
<h2>Resources</h2>
<ul>
  <li> <a href="https://docs.docker.com/engine/reference/builder/#run---mounttypesecret">Dockerfile reference</a> - RUN command secrets mount points
  </li>
  <li> <a href="https://docs.docker.com/engine/swarm/secrets/">Docker documentation</a> - Manage sensitive data with Docker secrets </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/522.html">MITRE, CWE-522</a> - Insufficiently Protected Credentials </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/798.html">MITRE, CWE-798</a> - Use of Hard-coded Credentials </li>
</ul>

